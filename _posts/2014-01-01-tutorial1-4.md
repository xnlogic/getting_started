---
tutorial_name:  "Your first xnlogic application"
tutorial_part:  4
tutorial_title: " Following relations"

date:   2014-01-01 12:04:00

categories: tutorial
---

In this part of the tutorial, we will create the `Tweet` type, and define a one-to-many relation between a user and their tweets.

## Update The Code

Create the file `lib/my_app/parts/tweet.rb` with the following code:

{% highlight ruby %}
module MyApp
  module Tweet
    xn_part

    property :text, type: :text

    from_one :User

  end
end
{% endhighlight %}

Edit `lib/my_app/models.rb`, and add the following entry to the `client_models` hash:
{% highlight ruby %}
tweet: [Tweet]
{% endhighlight %}

We should update `lib/my_app/parts/user.rb`, and define the relation from a user to their tweets.
{% highlight ruby %}
module MyApp
  module User
    xn_part

    property :username, type: :text
    property :email, type: :text

    to_many :Tweet
  end
end
{% endhighlight %}

__Important:__ If your console is open, you will need to reload the application code.

{% highlight ruby %}
jruby-1.7.18 :016 > MyApp.reload!
{% endhighlight %}


## Creating Tweets

For this part of the tutorial, we will "cheat" a little - We will bypass the API when creating our tweets. In the next tutorial, we will learn how to do it using the API.

Run the following code in the IRB
{% highlight ruby %}
tweets = ["It's a beautiful day", "Go #raptors!", "Learning #xnlogic is fun", "No more snow! #wintersucks"]
users = app.graph.v(MyApp::M::User).to_a

app.graph.transaction do
    while(not tweets.empty?) do
        u = users.shuffle[0]
        t = app.create(MyApp::M::Tweet, {text: tweets.pop()})
        u.add_tweets(t)
    end
end
{% endhighlight %}

OK, no more cheating, we promise.

## Follow Relations

As we've seen before, the following command will get a specific user.
{% highlight ruby %}
jruby-1.7.18 :017 > xget '/model/user/id/73'
{% endhighlight %}

If we want to read that user's tweets, we need to follow the `tweets` relation by adding `/rel/tweets` to the path.
{% highlight ruby %}
jruby-1.7.18 :018 > xget '/model/user/id/73/rel/tweets'
{:meta=>{:xnid=>"/model/tweet/id/81", :model_name=>"tweet", :rendered=>["record", "tweet"], :format=>"partial", :rel_limit=>50}, :id=>81, :name=>nil, :model_name=>"tweet", :description=>nil, :created_at=>2015-02-18 01:49:42 UTC, :text=>"No more snow! #wintersucks", :display_name=>81, :user=>{:meta=>{:xnid=>"/model/user/id/73", :model_name=>"user", :rendered=>["user", "record"], :format=>"compact"}, :id=>73, :name=>nil, :model_name=>"user", :display_name=>73}}
{:meta=>{:xnid=>"/model/tweet/id/82", :model_name=>"tweet", :rendered=>["record", "tweet"], :format=>"partial", :rel_limit=>50}, :id=>82, :name=>nil, :model_name=>"tweet", :description=>nil, :created_at=>2015-02-18 01:49:42 UTC, :text=>"Learning #xnlogic is fun", :display_name=>82, :user=>{:meta=>{:xnid=>"/model/user/id/73", :model_name=>"user", :rendered=>["user", "record"], :format=>"compact"}, :id=>73, :name=>nil, :model_name=>"user", :display_name=>73}}
Total: 2
 => #<Obj 1 ids -> lookup -> is_not(nil) -> V-Property(MyApp::M::User) -> V-Range(-1...1) -> outE(:tweet) -> inV -> V-Property(PacerModel::Extensions::M, PacerModel::Extensions::Record, MyApp::Tweet) -> V-Range(-1...100) -> Obj-Map>
{% endhighlight %}

> _Note:_ We follow relations by adding `/rel/RELATION_NAME` to a path. In case of a _many_ relation (e.g. a user has a relation to many tweets) the relation name is in its plural form.

We could also follow the relation in the opposite direction - Get a tweet by id, and follow its `user` relation.
{% highlight ruby %}
jruby-1.7.18 :019 > xget '/model/tweet/id/82/rel/user'
{:meta=>{:xnid=>"/model/user/id/73", :model_name=>"user", :rendered=>["record", "user"], :format=>"partial", :rel_limit=>50}, :id=>73, :name=>nil, :model_name=>"user", :description=>nil, :created_at=>2015-02-18 00:59:19 UTC, :username=>"cynthia", :email=>"sin.t.yeah@gmail.com", :display_name=>73}
Total: 1
 => #<Obj 1 ids -> lookup -> is_not(nil) -> V-Property(MyApp::M::Tweet) -> V-Range(-1...1) -> inE(:tweet) -> outV -> V-Property(PacerModel::Extensions::M, PacerModel::Extensions::Record, MyApp::User) -> V-Range(-1...1) -> Obj-Map>
{% endhighlight %}

> _Note:_ A tweet has a relation _from one_ user, therefore, the relation name is in its singular form.

As you might expect, we can chain queries (aka traversals) together.
{% highlight ruby %}
jruby-1.7.18 :020 > xget '/model/tweet/id/82/rel/user/properties/email'
[73, "sin.t.yeah@gmail.com"]
Total: 1
 => #<Obj 1 ids -> lookup -> is_not(nil) -> V-Property(MyApp::M::Tweet) -> V-Range(-1...1) -> inE(:tweet) -> outV -> V-Property(PacerModel::Extensions::M, PacerModel::Extensions::Record, MyApp::User) -> V-Range(-1...1) -> Obj-Map -> Obj-Range(-1...100)>
{% endhighlight %}

